<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Custom Sensitivities · Nabla.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Nabla.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Nabla.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="api.html">API</a></li><li class="is-active"><a class="tocitem" href="custom.html">Custom Sensitivities</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Legacy-Method"><span>Legacy Method</span></a></li><li><a class="tocitem" href="#Intercepting-calls"><span>Intercepting calls</span></a></li><li><a class="tocitem" href="#Defining-sensitivities"><span>Defining sensitivities</span></a></li><li><a class="tocitem" href="#Testing-sensitivities"><span>Testing sensitivities</span></a></li></ul></li><li><a class="tocitem" href="autodiff.html">Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="custom.html">Custom Sensitivities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="custom.html">Custom Sensitivities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/invenia/Nabla.jl/blob/master/docs/src/pages/custom.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Custom-Sensitivities"><a class="docs-heading-anchor" href="#Custom-Sensitivities">Custom Sensitivities</a><a id="Custom-Sensitivities-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Sensitivities" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Prefer to use ChainRulesCore to define custom sensitivities</header><div class="admonition-body"><p>Nabla supports the use of <a href="http://www.juliadiff.org/ChainRulesCore.jl/stable/">ChainRulesCore</a> to define custom sensitivities. It is preferred to define the custom sensitivities using <code>ChainRulesCore.rrule</code> as they will work for many AD systems, not just Nabla. <strong>It is also much easier, than the Nabla specific way</strong>. These sensitivities can be added in your own package, or for Base/StdLib functions they can be added to <a href="https://github.com/JuliaDiff/ChainRules.jl/">ChainRules.jl</a>. To define custom sensitivities using ChainRulesCore, define a <code>ChainRulesCore.rrule(f, args...; kwargs...)</code>. See the <a href="https://www.juliadiff.org/ChainRulesCore.jl/stable/">ChainRules project&#39;s documentation for more information</a>. <strong>If you are defining your custom sensitivities using ChainRulesCore then you do not need to read this page</strong>, and can consider it as documenting a legacy feature.</p><p>This page exists to describe how Nabla works, and how sensitivities can be directly defined for Nabla. Defining sensitivities this way does not make them accessible to other AD systems, but does let you do things that directly depend on how Nabla works. It allows for specific definitions of sensitivities that are only defined for Nabla (which might work differently to more generic definitions defined for all AD).</p></div></div><h1 id="Legacy-Method"><a class="docs-heading-anchor" href="#Legacy-Method">Legacy Method</a><a id="Legacy-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Legacy-Method" title="Permalink"></a></h1><p>Part of the power of Nabla is its extensibility, specifically in the form of defining custom sensitivities for functions. This is accomplished by defining methods for <code>∇</code> that specialize on the function for which you&#39;d like to define sensitivities.</p><p>Given a function of the form <span>$f(x_1, \ldots, x_n)$</span>, we want to be able to compute <span>$\frac{\partial f}{\partial x_i}$</span> for all <span>$i$</span> of interest as efficiently as possible. Defining our own sensitivities <span>$\bar{x}_i$</span> means that <span>$f$</span> will be taken as a &quot;unit,&quot; and its intermediate operations are not written separately to the tape. For more details on that, refer to the <a href="autodiff.html#Automatic-Differentiation">Details</a> section of the documentation.</p><h2 id="Intercepting-calls"><a class="docs-heading-anchor" href="#Intercepting-calls">Intercepting calls</a><a id="Intercepting-calls-1"></a><a class="docs-heading-anchor-permalink" href="#Intercepting-calls" title="Permalink"></a></h2><p>Nabla&#39;s approach to RMAD is based on operator overloading. Specifically, for each <span>$x_i$</span> we wish to differentiate, we need a method for <code>f</code> that accepts a <code>Node</code> in position <span>$i$</span>. There are two primary ways to go about this: <code>@explicit_intercepts</code> and <code>@unionise</code>.</p><h3 id="@explicit_intercepts"><a class="docs-heading-anchor" href="#@explicit_intercepts"><code>@explicit_intercepts</code></a><a id="@explicit_intercepts-1"></a><a class="docs-heading-anchor-permalink" href="#@explicit_intercepts" title="Permalink"></a></h3><p>When <code>f</code> has already been defined, we can extend it to accept <code>Node</code>s using this macro.</p><article class="docstring"><header><a class="docstring-binding" id="Nabla.@explicit_intercepts" href="#Nabla.@explicit_intercepts"><code>Nabla.@explicit_intercepts</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@explicit_intercepts(f::Symbol, type_tuple::Expr, is_node::Expr[, kwargs::Expr])
@explicit_intercepts(f::Symbol, type_tuple::Expr)</code></pre><p>Create a collection of methods which intecept the function calls to <code>f</code> in which at least one argument is a <code>Node</code>. Types of arguments are specified by the type tuple expression in <code>type_tuple</code>. If there are arguments which are not differentiable, they can be specified by providing a boolean vector <code>is_node</code> which indicates those arguments that are differentiable with <code>true</code> values and those which are not as <code>false</code>. Keyword arguments to add to the function signature can be specified in <code>kwargs</code>, which must be a <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Nabla.jl/blob/f12de3ea148f1b348615b1ee24ab2a63e68d92d5/src/sensitivity.jl#L28-L38">source</a></section></article><p>As a trivial example, take <code>sin</code> for scalar values (not matrix sine). We extend it for <code>Node</code>s as</p><pre><code class="language-julia hljs">import Base: sin  # ensure sin can be extended without qualification

@explicit_intercepts sin Tuple{Real}</code></pre><p>This generates the following code:</p><pre><code class="language-julia hljs">begin
    function sin(##367::Node{&lt;:Real})
        #= REPL[7]:1 =#
        Branch(sin, (##367,), getfield(##367, :tape))
    end
end</code></pre><p>And so calling <code>sin</code> with a <code>Node</code> argument will produce a <code>Branch</code> that holds information about the call.</p><p>For a nontrivial example, take the <code>sum</code> function, which accepts a function argument that gets mapped over the input prior to reduction by addition, as well as a <code>dims</code> keyword argument that permits summing over a subset of the dimensions of the input. We want to differentiate with respect to the input array, but not with respect to the function argument nor the dimension. (Note that Nabla cannot currently differentiate with respect to keyword arguments.) We can extend this for <code>Node</code>s as</p><pre><code class="language-julia hljs">import Base: sum

@explicit_intercepts(
    sum,
    Tuple{Function, AbstractArray{&lt;:Real}},
    [false, true],
    (dims=:,),
)</code></pre><p>The signature of the call to <code>@explicit_intercepts</code> here may look a bit complex, so let&#39;s break it down. It&#39;s saying that we want to intercept calls to <code>sum</code> for methods which accept a <code>Function</code> and an <code>AbstractArray{&lt;:Real}</code>, and that we do not want to differentiate with respect to the function argument (<code>false</code>) but do want to differentiate with respect to the array (<code>true</code>). Furthermore, methods of this form will have the keyword argument <code>dims</code>, which defaults to <code>:</code>, and we&#39;d like to make sure we&#39;re able to capture that when we intercept.</p><p>This macro generates the following code:</p><pre><code class="nohighlight hljs">quote
    function sum(##363::Function, ##364::Node{&lt;:Array}; dims=:)
        #= REPL[2]:1 =#
        Branch(sum, (##363, ##364), getfield(##364, :tape); dims=dims)
    end
end</code></pre><p>As you can see, it defines a new method for <code>sum</code> which has positional arguments of the given types, with the second extended for <code>Node</code>s, as well as the given keyword arguments. Notice that we do not accept a <code>Node</code> for the function argument; this is by virtue of using <code>false</code> in that position in the call to <code>@explicit_intercepts</code>.</p><h3 id="@unionise"><a class="docs-heading-anchor" href="#@unionise"><code>@unionise</code></a><a id="@unionise-1"></a><a class="docs-heading-anchor-permalink" href="#@unionise" title="Permalink"></a></h3><p>If <code>f</code> has not yet been defined and you know off the bat that you want it to be able to work with Nabla, you can annotate its definition with <code>@unionise</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Nabla.@unionise" href="#Nabla.@unionise"><code>Nabla.@unionise</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@unionise code</code></pre><p>Transform code such that each function definition accepts <code>Node</code> objects as arguments, without effecting dispatch in other ways.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Nabla.jl/blob/f12de3ea148f1b348615b1ee24ab2a63e68d92d5/src/code_transformation/differentiable.jl#L149-L154">source</a></section></article><p>As a simple example,</p><pre><code class="language-julia hljs">@unionise f(x::Matrix, p::Real) = norm(x, p)</code></pre><p>For each type constrained argument <code>xi</code> in the method definition&#39;s signature, <code>@unionise</code> changes the type constraint from <code>T</code> to <code>Union{T, Node{&lt;:T}}</code>, allowing <code>f</code> to work with <code>Node</code>s without needing to define separate methods. In this example, the macro expands the definition to</p><pre><code class="language-julia hljs">f(x::Union{Matrix, Node{&lt;:Matrix}}, p::Union{Real, Node{&lt;:Real}}) = begin
        #= REPL[9]:1 =#
        norm(x, p)
    end</code></pre><h2 id="Defining-sensitivities"><a class="docs-heading-anchor" href="#Defining-sensitivities">Defining sensitivities</a><a id="Defining-sensitivities-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-sensitivities" title="Permalink"></a></h2><p>Now that our function <code>f</code> works with <code>Node</code>s, we want to define a method for <code>∇</code> for each argument <code>xi</code> that we&#39;re interested in differentiating. Thus, for each argument position <code>i</code> we care about, we&#39;ll define a method of <code>∇</code> that looks like:</p><pre><code class="language-julia hljs">function Nabla.∇(::typeof(f), ::Type{Arg{i}}, _, y, ȳ, x1, ..., xn)
    # Compute x̄i
end</code></pre><p>The method signature contains all of the information it needs to compute the derivative:</p><ul><li><code>f</code>, the function</li><li><code>Arg{i}</code>, which specifies which of the <code>xi</code> we&#39;re computing the sensitivity of</li><li><code>_</code> (placeholder, typically unused)</li><li><code>y</code>, the result of <code>y = f(x1, ..., xn)</code></li><li><code>ȳ</code>, the &quot;incoming&quot; sensitivity propagated to this call</li><li><code>x1, ..., xn</code>, the inputs to <code>f</code></li></ul><p>A fully worked example is provided in the <a href="autodiff.html#Automatic-Differentiation">Details</a> section of the documentation.</p><h2 id="Testing-sensitivities"><a class="docs-heading-anchor" href="#Testing-sensitivities">Testing sensitivities</a><a id="Testing-sensitivities-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-sensitivities" title="Permalink"></a></h2><p>In order to ensure correctness for custom sensitivity definitions, we can compare the results against those computed by the method of finite differences. The finite differencing itself is implemented in the Julia package <a href="https://github.com/invenia/FDM.jl">FDM</a>, but Nabla defines and exports functionality that permits checking results against finite differencing.</p><p>The primary workhorse function for this is <code>check_errs</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Nabla.check_errs" href="#Nabla.check_errs"><code>Nabla.check_errs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_errs(
    f,
    ȳ::∇ArrayOrScalar,
    x::T,
    v::T,
    ε_abs::∇Scalar=1e-10,
    ε_rel::∇Scalar=1e-7
)::Bool where T</code></pre><p>Check that the difference between finite differencing directional derivative estimation and RMAD directional derivative computation for function <code>f</code> at <code>x</code> in direction <code>v</code>, for both allocating and in-place modes, has absolute and relative errors of <code>ε_abs</code> and <code>ε_rel</code> respectively, when scaled by reverse-mode sensitivity <code>ȳ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/invenia/Nabla.jl/blob/f12de3ea148f1b348615b1ee24ab2a63e68d92d5/src/finite_differencing.jl#L91-L105">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="api.html">« API</a><a class="docs-footer-nextpage" href="autodiff.html">Details »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 4 July 2022 02:56">Monday 4 July 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
