# Custom Sensitivities

Part of the power of Nabla is its extensibility, specifically in the form of defining
custom sensitivities for functions.
This is accomplished by defining methods for `∇` that specialize on the function for
which you'd like to define sensitivities.

Given a function of the form ``f(x_1, \ldots, x_n)``, we want to be able to compute
``\frac{\partial f}{\partial x_i}`` for all ``i`` of interest as efficiently as possible.
Defining our own sensitivities ``\bar{x}_i`` means that ``f`` will be taken as a "unit,"
and its intermediate operations are not written separately to the tape.
For more details on that, refer to the [Details](@ref Automatic-Differentiation) section
of the documentation.

## Intercepting calls

Nabla's approach to RMAD is based on operator overloading.
Specifically, for each ``x_i`` we wish to differentiate, we need a method for `f` that
accepts a `Node` in position ``i``.
There are two primary ways to go about this: `@explicit_intercepts` and `@unionise`.

### `@explicit_intercepts`

When `f` has already been defined, we can extend it to accept `Node`s using this macro.

```@docs
@explicit_intercepts
```

As a trivial example, take `sin` for scalar values (not matrix sine).
We extend it for `Node`s as

```julia
import Base: sin  # ensure sin can be extended without qualification

@explicit_intercepts sin Tuple{Real}
```

This generates the following code:

```julia
begin
    function sin(##367::Node{<:Real})
        #= REPL[7]:1 =#
        Branch(sin, (##367,), getfield(##367, :tape))
    end
end
```

And so calling `sin` with a `Node` argument will produce a `Branch` that holds information
about the call.

For a nontrivial example, take the `sum` function, which accepts a function argument
that gets mapped over the input prior to reduction by addition, as well as a `dims`
keyword argument that permits summing over a subset of the dimensions of the input.
We want to differentiate with respect to the input array, but not with respect to the
function argument nor the dimension.
(Note that Nabla cannot currently differentiate with respect to keyword arguments.)
We can extend this for `Node`s as

```julia
import Base: sum

@explicit_intercepts(
    sum,
    Tuple{Function, AbstractArray{<:Real}},
    [false, true],
    (dims=:,),
)
```

This macro generates the following code:

```
function _sum(arg1::Function, arg2::AbstractArray{<:Real}, dims=:)
    #= REPL[6]:1 =#
    sum(arg1, arg2; dims=dims)
end
begin
    begin
        function sum(##365::Function, ##366::Node{<:AbstractArray{<:Real}}; dims=:)
            #= REPL[6]:1 =#
            _sum(##365, ##366, dims)
        end
        function _sum(##365::Function, ##366::Node{<:AbstractArray{<:Real}}, dims::Any)
            #= REPL[6]:1 =#
            Branch(_sum, (##365, ##366, dims), getfield(##366, :tape))
        end
    end
end
```

As you can see, it defines a new function `_sum` which has all positional arguments
but is otherwise equivalent to `sum`.
It then extends `sum` to call `_sum` when passed a `Node`, and `_sum` in turn creates
a `Branch` when it receives a `Node`.

The name `_sum` is generated by an internal function `Nabla.kwfname`, which generates
a name for a function that accepts positional arguments based on one with keyword
arguments.
Currently the naming scheme is to simply prepend an underscore.

!!! warning
    When dealing with functions with keyword arguments, methods for `∇` should be
    specialized on `Nabla.kwfname(f)`, _not_ `f`!

### `@unionise`

If `f` has not yet been defined and you know off the bat that you want it to be able to
work with Nabla, you can annotate its definition with `@unionise`.

```@docs
@unionise
```

As a simple example,

```julia
@unionise f(x::Matrix, p::Real) = norm(x, p)
```

For each type constrained argument `xi` in the method definition's signature, `@unionise`
changes the type constraint from `T` to `Union{T, Node{<:T}}`, allowing `f` to work with
`Node`s without needing to define separate methods.
In this example, the macro expands the definition to

```julia
f(x::Union{Matrix, Node{<:Matrix}}, p::Union{Real, Node{<:Real}}) = begin
        #= REPL[9]:1 =#
        norm(x, p)
    end
```

## Defining sensitivities

Now that our function `f` works with `Node`s, we want to define a method for `∇` for each
argument `xi` that we're interested in differentiating.
Thus, for each argument position `i` we care about, we'll define a method of `∇` that
looks like:

```julia
function Nabla.∇(::typeof(f), ::Type{Arg{i}}, _, y, ȳ, x1, ..., xn)
    # Compute x̄i
end
```

The method signature contains all of the information it needs to compute the derivative:

* `f`, the function
* `Arg{i}`, which specifies which of the `xi` we're computing the sensitivity of
* `_` (placeholder, typically unused)
* `y`, the result of `y = f(x1, ..., xn)`
* `ȳ`, the "incoming" sensitivity propagated to this call
* `x1, ..., xn`, the inputs to `f`

A fully worked example is provided in the [Details](@ref Automatic-Differentiation) section
of the documentation.

As stated earlier, if `f` accepts keyword arguments then we'll need to extend `∇` for
`Nabla.kwfname(f)` rather than `f`.
However, note that `kwfname` returns a `Symbol`, not a `Function`, which means a bit of
trickery is involved when forming the method signature.
One effective, if not entirely beautiful, way to accomplish it is to use `@eval`:

```julia
@eval function Nabla.∇(::typeof($(Nabla.kwfname(f))), ...)
    # ...
end
```

## Testing sensitivities

In order to ensure correctness for custom sensitivity definitions, we can compare the
results against those computed by the method of finite differences.
The finite differencing itself is implemented in the Julia package
[FDM](https://github.com/invenia/FDM.jl), but Nabla defines and exports functionality
that permits checking results against finite differencing.

The primary workhorse function for this is `check_errs`.

```@docs
check_errs
```
